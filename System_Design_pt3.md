## 2.7 엘라스틱 서치(Elastic Search)

### 2.7.1 엘라스틱 서치 소개

소프트웨어 엔지니어 더그 커팅이 고안한 inverted index 구조의 검색엔진 루씬을 기반으로 하는 검색 엔진으로

REST API 와 스키마 없는 JSON 문서 기능을 제공하며 Java 로 개발되었다.

#### 2.7.1.1 관련 용어 설명

**document**

엘라스틱 서치에서 데이터가 저장되는 최소 단위로 JSON 포맷으로 저장된다. DB의 row에 대응된다.

**index**

데이터 저장 공간으로 하나의 노드에 여러 개 인덱스가 생성된다. 하나의 인덱스가 여러 노드에

분산되어 저장된다.

**Shard**

인덱싱된 document 는 인덱스 - 인덱스 내부 데이터로 이루어져 있고 이는 다시 여러 개의 부분으로

나뉘어 구성되는데 이 나뉘어진 부분들을 Shard 라 한다.

**Type**

인덱스의 논리적 구조로 엘라스틱 서치 6.1 부터 인덱스 하나당 하나의 타입만 설정 가능하다.

**Field**

document 를 구성하기 위한 속성으로 DB 의 column 에 대응된다볼 수 있다. 하나의 필드는 목적에 따라

다수의 데이터 타입을 가질 수 있다.

**indexing**

document 의 위치에 대한 인덱스를 만들어 접근성을 높이는 프로세스

**Mapping**

document의 필드, 필드 속성을 정의하고 그에 따른 인덱싱 방법을 정의하는 프로세스, 스키마 정의

프로세스라 볼 수 있다.

**inverted indexing**

일반적인 인덱싱과 반대로 document 내의 내용물의 Mapping 정보를 인덱싱하는 것이다.

검색엔진과 같은 문서 내용의 검색이 필요한 형태에서 보다 전문적인 형태의 검색 수행을 위해 사용된다.

**JSON**

JSON 은 "JavaScript Object Notation" 의 약자로 사람이 읽을 수 있는 문자를 사용하여 속성-값 쌍 및

배열 형태로 구성된 데이터 객체를 저장하고 전송하는 개방형 표준 파일 형식 겸 데이터 교환 형식

이다. 서버가 있는 웹 어플리케이션에서 데이터 교환시 다양한 용도로 사용된다.

JSON 은 언어 독립적인 형식이며 JavaScript 에서 파생되었지만 많은 근래의 프로그래밍 언어 플랫폼은

JSON 형식 데이터를 생성하고 분석하는 기능을 지원하고 있다. JSON 파일 이름은 `.json`

확장자를 사용한다. JSON 의 기본 데이터 유형은 아래와 같다.

- 숫자

  소수 부분을 포함할 수 있고 지수 E 표기법을 사용할 수 있는 부호 있는 십진수 형태를 표현하는 타입

  입니다. NaN과 같은 숫자가 아닌 것은 포함할 수 없다. 또한 정수와 부동 소수점을 구분하지

  않습니다. JSON의 모태가 되는 JavaScripte의 경우 모든 숫자 값에 대해 배정밀도 부동 소수점 형식

  (64비트를 사용한 정밀도 표현)을 사용하지만 JSON은 사용하는 언어에 따라 숫자가 다르게

  인코딩될 수 있다.

- 문자열

  0개 이상의 유니코드 형태로 표현되는 문자를 다루는 타입으로, 큰따옴표로 문자와 구분되며

  백슬래시 이스케이프 구문을 지원한다.

- Bool

  `true` 또는 `false` 값을 표현할 때 사용되는 타입이다.

- Array

  배열을 표현하는 타입으로 0개 이상의 요소로 구성될 수 있다. 배열은 쉼표로 구분된 요소와 함께

  대괄호 표기법으로 사용한다.

- Object

  이름(키)이 문자열인 이름-값 쌍의 집합이다. JSON 구문에서는 이름으로 사용되는 문자열이

  고유성을 가져야 된다거나 하는 제한을 따로 두고 있지 않으며 이름/값 쌍의 순서에 대해

  별다른 의미를 부여하지 않는다. 객체는 중괄호로 구분되고 쉼표를 사용하여 각 쌍을 구분하며

  `:` 문자를 사용하여 키 또는 이름과 해당 값을 구분한다.

**REST API**

- API

  Application Programming Interface 의 약자인 API 는 프로그래밍에서, 프로그램을 작성하기 위한

  일련의 부차적 프로그램으로 프로토콜 등을 정의하여 통신을 하기 위한 인터페이스 사양을

  말한다. API 자체는 어디까지나 사양만을 정의하기 때문에 구현과는 독립적이다. 이를 실제로 구현한

  것은 라이브러리라고 부른다. 소프트웨어 개발에서 호환성을 위해 지켜야하는 추상적 원칙이라고

  볼 수 있으며 한마디로, 소스 코드 수준에서 정의되는 인터페이스라고 정리할 수 있다.

- REST

  Representational State Transfer 은 컴퓨터 과학자 로이 필딩이 2000년 박사 학위 논문에 정의한

  네트워크 소프트웨어 아키텍쳐로 간단히 말하여 '네트워크 통신 구조 설계 지침' 이다.

  네트워크 통신을 위해 제시되었으나 온라인 네트워크 통신 작용의 대부분을 차지하는 웹 기반의 전송을

  위해 주로 사용되고 있다. REST 의 조건은 아래와 같다.

| 조건                 | 설명                                                         |
| -------------------- | ------------------------------------------------------------ |
| Client-Server        | 클라이언트와 서버로 분리되어야 하며 서로 의존성이 없어야 한다. |
| Stateless(무상태성)  | 상태 정보를 따로 저장하지 않으며, 결과가 이용자의 정보와 관계 없이 동일해야 한다. |
| Cache                | HTTP를 비롯한 네트워크 프로토콜에서 제공하는 캐싱 기능을 적용할 수 있어야 한다. |
| Uniform Interface    | 데이터가 표준 형식으로 전송될 수 있도록 구성 요소간 통한 인터페이스를 사용한다. |
| Layered System       | 요청된 정보를 검색하는 데 있어 계층 구조로 분리되어야 한다.  |
| Self-descriptiveness | 전송되는 내용은 별도 문서 없이 쉽게 이해할 수 있도록 자체 표현 구조를 지녀야 한다. |

- REST API

  REST 를 준수하는 API 를 말하며 주로 HTTP 기반 네트워크에서 사용된다.

  프로그래밍에서 말하는 API 와의 차이점으론 프로그래밍의 API는 코드나 라이브러리를 받아오기

  위해 사용되지만 REST API 는 네트워크에서 데이터를 받아오기 위한 용도이다.

  단순 데이터 열람에 활용되는 경우가 많아 광범위하게 사용된다.

**NoSQL**

NoSQL 은 의견에 따라 No SQL, Not Only SQL, Non-Relational Operational DB SQL 등으로 정의가

엇갈리는 면이 있으나 Not only SQL 로 해석하는 측이 다수를 차지하고 있다.

의미를 풀어보면, 단순히 기존 관계형 DBMS(RDBMS)가 가지고 있는 특성뿐만 아니라, 다른 특성들을

부가적으로 지원한다는 것을 의미한다. 이 정의는 1998년 엔지니어 카를로스 스트로찌가 공개한

표준 SQL를 채용하지 않은 자신의 경량 오픈 소스 DB 를 NoSQL 이라 명명한데서 유래했다고 전해진다.

이 때 이후 기존의 관계형 DBMS 시스템의 주요 특성인 ACID 를 제공하지 않지만 보다 뛰어난 확장성이나

성능을 가지는 많은 비관계형, 분산 DBMS 를 지칭하는 데 보편적으로 사용되게 되었다.

2000년 후반에 소셜네트워크 서비스등이 등장하며 관계데이터 또는 정형데이터가 아닌 비정형데이터라는 것을

쉽게 저장하고 처리할 수 있는 구조를 가진 DB들이 대두되었고, 해당 기술이 발전되며 NoSQL 데이터베이스가

각광을 받게 되었다. 기존의 관계형 DB 들과 구분되는 차이점은 아래와 같습니다.

- 관계형 모델을 사용하지 않으며 테이블간의 조인 기능을 제공하지 않음
- 직접 프로그래밍을 하는 등의 비SQL 인터페이스를 통한 데이터 접근 방식
- 대부분 여러 대의 DB 서버를 묶어서 하나의 DB를 구성
- 관계형 DB에서 지원하는 데이터 처리 완결성(ACID) 미보장
- 데이터의 스키마와 속성들을 다양하게 수용 및 동적 정의
- 데이터베이스의 중단 없는 서비스와 자동 복구 기능 지원
- 다수가 오픈 소스 형태로 제공

**검색 엔진**

검색엔진은 내부적으로 각 도큐먼트를 인덱싱하고 빠르게 검색하는데 사용하는 기술로 검색 엔진을 이용해

만든 대표적인 서비스로는 네이버, 구글과 같은 형태가 있다.

### 2.7.2 엘라스틱 서치 라이선스

Elastic 사는 엘라스틱 서치 7.11 버젼부터 새로운 라이센스인 SSPL(Server Side Public License) 또는 Elastic 라이센스 중에서

하나를 골라 사용할 수 있는 Dual 라이선스를 발표하면서 기존의 아파치 2.0 라이센스를 더는 제공하지 않는다고 발표하였다.

SSPL 은 GPL3와 유사한 라이선스로써 해당 소스를 이용하여 서비스를 제공하는 제 3자는 서비스 구축시 사용된 모든 소스를

공개하도록 제한하고 있다. 이 전환은 일부 클라우드 서비스 공급자들이 오픈 소스 커뮤니티에 기여하지 않고 서비스를 제공하며

사용자와 커뮤니티에 피해를 준다는 Elastic 사의 견해로 인해 발생했다.

### 2.7.3 엘라스틱 서치 특징

**특징**

엘라스틱 서치는 NoSQL의 일종으로 분류될 수 있고, 분산 처리를 통해 실시간성으로 빠른 검색이 가능하다.

특히 기존 처리 방식으로 작업이 어려운 대량의 비정형 데이터 검색이 가능하며 전문 검색이나 구조 검색

모두를 지원한다.

**장점**

- 오픈 소스형 검색 엔진이다. 오픈 소스 커뮤니티가 엘라스틱 서치를 계속해서 개선하고 있다.
- 내용 전체를 인덱싱해서 특정 단어가 포함된 문서를 검색할 수 있는 전문 검색 기능을 제공한다.
- 비정형 로그 데이터를 수집하여 통계 분석에 활용할 수 있다.
- 정형화되지 않은 문서도 자동으로 인덱싱하고 검색할 수 있다.(Schemaless)
- HTTP 기반의 REST API 를 활용하고 요청/응답에 JSON을 활용해 언어, OS, 시스템에 독립적이다.
- 서로 상이한 인덱스더라도 검색할 필드명만 같으면 여러 인덱스를 한 번에 조회할 수 있다.
- 여러 계층 구조의 문서로 저장이 가능하며, 계층 구조로 된 문서도 한 번의 쿼리로 조회할 수 있다.
- inverted indexing 기능을 지원한다.
- Shard 를 활용해 분산 구성이 가능하다. 이는 확장성을 보장한다.

**단점**

- 완전히 실시간으로 기능하지는 않는다. 인덱싱된 데이터가 내부적인 작업으로 1초 뒤 검색이 가능하다.
- 전체적인 성능 향상을 위해 시스템적으로 비용 소모가 큰 롤백, 트랜잭션을 지원하지 않는다.
- 데이터 업데이트를 제공하지 않는다. 업데이트 명령시 기존 문서 삭제후 새 문서를 생성한다.

#### 엘라스틱 스택

모든 유형의 데이터, 특히 비정형 데이터를 저장, 실시간 검색, 분석 및 시각화할 수 있도록 도와주는

Elastic 사의 오픈소스 서비스 제품이다. 단순 검색 엔진인 엘라스틱서치(elastic search)에 오픈소스

데이터 수집 도구인 로그스테시(Logstash), 오픈소스 시각화 UI인 키바나(Kibana), 경량 데이터 수집기인

비트(Beat)가 더해져 엘라스틱 스택이 생성되었다.

**키바나**

키바나는 엘라스틱 스택의 UI를 담당한다. 엘라스틱서치에 대한 대부분의 관리기능, API를 실행할 수 있는

콘솔, 솔루션 페이지들 등이 모두 포함되어 있다. 가장 중요한 기능은 데이터 시각화 기능이다.

다양한 차트나 그래프를 클릭 몇번으로 생성할 수 있다.

**로그스태시**

대량의 데이터를 검색하기 위해 가장 먼저 선향돼야 할 작업은 데이터를 적재하는 것이다. 데이터 수집과 가공

기능을 제공하는 로그스태시를 사용하면 다양한 소스로부터 데이터를 수집할 수 있다. 또한 필터 기능을 이용해

비정형 데이터를 분석하기 쉬운 형태로 정제할 수 있고 엘라스틱 서치 외에도 다양한 플랫폼으로 정제된 데이터

를 보낼 수 있다. 로그스태시의 진면목은 엘라스틱서치의 인덱싱 성능을 최적화하기 위한 배치 처리와 병렬 처

리가 가능하다는 것이다.

**비츠**

로그스테시의 기능은 충분히 강력하다. 하지만 다양한 필터와 설정을 지원하는 만큼 무겁기 때문에

활용도가 떨어지는 경우도 있다. 따라서 엘라스틱 스택에는 비츠라는 경량 수집기가 포함되어 있다.

**엘라스틱 스택 Work Flow**

1. 엘라스틱 서치가 매핑을 설정한다.
2. 로그스태시가 데이터를 전처리하고 전송한다.
3. 엘라스틱 서치가 데이터를 저장한다.
4. 키바나에 인덱스가 등록되고 차트 옵션등을 사용자로부터 선택 받은 후 데이터를 시각화한다.

### 2.7.4 서비스에서의 기능

사용자에게 필요한 정보를 제공하기 위해 크롤링, 추출을 통해 얻어난 데이터를 기반으로 검색을 수행합니다.

## 2.8 PostgreSQL

### 2.8.1 PostgreSQL 소개

#### 관련 용어 설명

**데이터 무결성**

완전한 수명 주기를 가지며 데이터의 정확성과 일관성을 유지하고 보증하는 것을 말한다.

**DataBase**

여러 사람에 의해 공유되어 사용될 목적으로 통합되어 관리되는 데이터의 집합을 말한다. 특정 다수의 이용자들에게 필요한 정보를

제공하거나 조직 내에서 필요한 정보를 체계적으로 축적하여 그 조직 내의 이용자들에게 필요한 정보를 제공하는 정보 서비스에

이용되며 일반적으로 응용 프로그램과 별개의 미들웨어를 통해서 관리된다. 데이터베이스는 아래의 특징을 가진다.

- 자기기술성

  파일 시스템과 구별되는 특징으로 데이터의 삽입/삭제를 데이터/구조적 종속 없이 가능케 하는 것을 말한다.

  DBMS 에 의해 실현된다.

- 프로그램과 데이터의 격리

  단일 응용 프로그램 내에서 데이터를 개별적으로 관리하는 방식은 데이터 저장 구조 등이 변경되면 응용 프로그램도 수정되어야

  한다. 하지만 데이터베이스는 앞서 언급된 자기기술성을 가지므로 저장 구조 등을 수정하는 것이 응용 프로그램에 영향을

  주지 않는다.

- 추상화

  복잡한 데이터베이스 구조에 대한 정보를 감추고, 각 사용자에게 뷰를 제공한다.

- 동시성 제어

  특정 적용 업무나 응용 시스템이 아닌 동시에 복수의 적용 업무나 응용 시스템에 대한 공유할 필요가 있는

  데이터를 보관하고 관리한다. 이를 통해 다수의 사용자에게 동시 접근을 제공한다.

- 동일한 내용의 데이터가 공존하지 않아야 하고, 다양한 접근 방식이 존재해야 하며, 검색과 갱신이 효율적으로 이뤄져야 한다.

- RAM ,ROM 같은 주기억장치가 아닌 보조기억장치에 저장된다.

- 데이터 베이스 설계

  데이터베이스 설계는 아래와 같은 단계를 거친다.

  1. 요구 조건 분석 : 사용자가 어떤 정보를 필요로 하는 지, 문제가 무엇인지 분석하여 데이터베이스의 용도와 형태를 결정한다.
  2. 개념적 설계 : 데이터베이스의 구성요소들을 정하고, 다음 단계에서 수행할 작업을 설계한다.
  3. 논리적 설계 : 본격적인 스키마 설계로, 이전 단계에서 만들어 놓은 설계도를 가시적 형태로 작업한다.
  4. 물리적 설계 : 저장장치에 저장되는 형태의 알고리즘을 효율적이게 개선하고 수정하는 단계이다.
  5. 구현 : 실제 데이터들을 수집한 뒤 데이터베이스에 반영한다.
  6. 운영 및 개선 : 데이터베이스를 실제로 운영하며 사용시 발생하는 문제점들을 개선한다.

**트랜잭션**

데이터베이스에서 데이터에 대한 하나의 논리적 실행단계를 트랜잭션이라고 한다.

**ACID**

ACID 는 데이터베이스 트랜잭션이 안전히 수행되는 것을 보장되기 위한 성질을 가리키는 약어이다. 아래와 같이 구성된다.

- 원자성(Atomicity)

  트랜잭션과 관련된 작업들이 부분적으로 실행되다가 중단되지 않는 것을 보장하는 능력이다.

- 일관성(Consistency)

  트랜잭션이 실행을 성공적으로 완료하면 언제나 일관성 있는 데이터베이스 상태를 유지하는 것을 의미한다.

- 독립성(Isolation)

  트랜잭션 수행시 다른 트랜잭션의 연산 작업이 끼어들지 않도록 보장하는 것을 의미한다. 트랜잭션 외에 어떤 연산도

  연산중인 데이터에 접근할 수 없다. 성능관련 이유로 인해 보장되지 않는 경우도 존재한다.

- 지속성(Durability)

  성공적으로 수행된 트랜잭션은 영원히 반영되어야 함을 의미한다. 모든 트랜잭션은 로그로 남고 장애 발생시

  그 이전 상태로 되도릴 수 있다.

**DBMS**

데이터베이스를 형성하고, 저장 및 관리할 수 있는 기능들을 제공하는 응용프로그램이다. 아래와 같은 기능을 가진다.

- 중복 제어 : 동일 데이터가 여러 위치에 중복 저장되는 현상을 방지한다. 저장 공간의 낭비를 막고 데이터 일관성을 유지한다.

- 접근 통제 : 사용자마다 다양한 권한을 부여할 수 있으며, 권한에 따라 데이터에 대한 접근을 제어할 수 있다.

- 인터페이스 제공 : 사용자에게 SQL 및 CLI , GUI 등 다양한 인터페이스를 제공한다.

- 관계 표현 : 서로 다른 데이터간의 다양한 관계를 표현할 수 있는 기능을 제공한다.

- 무결성 제약 조건

  데이터 무결성에 관한 제약조건을 정의/검사하는 기능을 제공한다. 데이터베이스는 반드시 무결성 제약조건을

  통과한 데이터만을 저장해야한다.

대다수의 DBMS 는 비교적 크기가 작은 데이터들을 많이 저장하는 것에 특화되어 있어 데이터의 크기 자체가 클 경우

오버헤드가 클 수 있다는 한계가 존재한다. 또한 실시간 데이터 처리가 필요한 경우에도 복잡한 기능을 제공하는 DBMS는

적합하지 않다.

**Schema**

데이터베이스에서 자료의 구조, 자료의 표현 방법, 자료 간의 관계를 형식 언어로 정의한 구조이다. DBMS 는 주어진

설정에 따라 이 스키마를 생성하며, 사용자가 자료를 저장, 조회, 삭제, 변경할 때 DBMS가 그것을 참조하여 작업을 수행한다.

스키마는 3계층 구조로 구성된다.

- 외부 스키마 : 프로그래머, 사용자의 입장에서의 데이터베이스 모습으로 구조의 일부분을 정의한 것
- 개념 스키마 : 모든 응용 시스템과 사용자들이 필요로 하는 데이터를 통합한 전체 데이터베이스 구조를 논리적으로 정의한 것
- 내부 스키마 : 전체 데이터베이스의 물리적 저장 형태를 기술하는 것

**SQL**

Structured Query Language 의 약어인 SQL 은 관계형 데이터베이스 시스템(RDBMS)의 데이터를 관리하기 위해 설계된 특수

목적의 프로그래밍 언어이다. RDBMS 에서 자료의 검색, 관리, 스키마 생성/수정, 데이터베이스 객체 접근 조정 관리를 위해

고안되었으며, 많은 DB 관련 프로그램들이 SQL 을 채택하고 있다. SQL 문법의 종류는 아래 세 가지로 구분된다.

- 데이터 정의 언어
- 데이터 조작 언어
- 데이터 제어 언어

**RDBMS**

관계형 데이터베이스는 1970년 컴퓨터 과학자, 에드거 F.커드가 제안한 관계형 모델에 기초하는 데이터베이스로 키와 값들의

간단한 관계를 테이블화 시킨 매우 간단한 데이터베이스 형태이다. 관계형 모델은 데이터를 열과 행을 이루는 하나 이상의

테이블로 관리하며, 고유 키가 각 행을 식별한다. 행을 레코드나 튜플로 불리기도 한다. 각 테이블은 하나의 개체 타입을

의미하며 행은 그 개체의 속성이 되는 값들을 묘사한다. 테이블의 각 행에는 각 고유 키가 존재하는데 이는 다른 테이블의

행으로도 연결 가능하고 연결된 행의 고유 키를 위한 열인 외래 키를 해당 테이블에 추가하여 실현할 수 있다.

테이블은 같은 속성을 지닌 튜플의 모임으로 정의되는데 일반적으로 한 대상 객체를 묘사할 때 사용된다.

제약을 사용하면 속성의 범위에 추가적으로 제한을 둘 수 있다.

#### PostgreSQL

PostgreSQL 은 무료, 오픈소스 RDBMS 로 데이터베이스 계의 거장 Michael Stonebraker 가 시작한

Ingre(INteractive Graphics REtrieval System) 에서 파생된 프로젝트인 Postgres 는 Post-Ingres 의 줄임말인데

PostgreSQL 은 이 프로젝트에 SQL 을 지원하고 오픈소스가 되며 1997년에 공식적으로 출시되었다.

BSD, MIT 라이선스와 같은 개방 라이선스와 유사한 고유 라이선스를 사용해 상용적인

사용과 수정을 허용하지만, 사용 중 발생하는 문제에 대해 법적 책임이 없음을 분명히 하고 있다.

PostgreSQL 의 로고는 코끼리인데 정확한 근원은 없으나 오픈소스화된 직후 한 사용자가 아가사

크리스트의 소설 '코끼리는 기억한다' 에서 착안해 제안한 것이 가장 유력한 이유이다.

이외에 코끼리가 크고 강하고 믿음직하며 기억력이 좋다는 점때문에 채택되었다는 설도 있다.

**현황**

PostgreSQL 의 사용자 성향을 조사해보면 대부분 개발적인 성향을 띄며 제품에 대한 애정도와 충성도가 높은 것으로 나타난다.

프로젝트 페이지에 잘 정리된 메뉴얼과 많은 관련 서적, 세계 각국에서 개최되는 다양한 세미나와 컨퍼런스가 이를 뒷받침하고

있다. 특히 근래 클라우드 분야에서 DbaaS(DB As A Service)를 제공하는 기업이 늘어나면서 비용과 라이선스 측면에서 유리한

PostgreSQL 에 대한 수요가 증가하고 있고 이에 대응해 관련 제품이 출시되기도 하였다. MySQL 을 가진 Sun이 2009년 Oracle

에 인수되면서 좀 더 폐쇠적인 기업형 프로젝트 성향을 보이고 그로 인해 많은 사용자 이탈이 발생하자 손쉽게 이전할 수 있는

PostgreSQL 이 주목을 받았고 이후 사용자가 점진적으로 증가하는 추세이다.

### 2.8.2 PostgreSQL 라이선스

PostgerSQL 은 BSD 또는 MIT 라이선스와 유사한 자유-오픈 소스 라이선스인 PostgreSQL 라이선스에 따라 출시된다.

어떤 목적으로든 무료로 별도의 동의 없이 사용, 복사, 수정 및 배포할 수 있는 권한이 부여된다. 다만, PostgreSQL 개발사측은

사용으로 인해 발생하는 결과에 대해 책임을 지지 않는다.

### 2.8.3 PostgreSQL 특징

**다중 버전 동시성 제어**

PostgerSQL 은 MVCC(Multiversion Concurrency Control)를 통해 동시성을 관리한다. 이 제어는 각 트랜잭션에 데이터베이스의

'스냅샷'을 제공하며 다른 트랜잭션에 영향을 주지 않고 변경이 가능하게 한다. 이를 통해 읽기 작업시 락을 거는 것을 필요치 않게 하고

데이터베이스가 ACID 를 유지할 수 있게 해준다.

**외부 데이터 래퍼**

PostgreSQL 은 외부 데이터 래퍼(FDW)를 통해 데이터를 검색하기 위해 다른 시스템에 연결할 수 있다. 파일 시스템, 다른

관계형 데이터베이스 또는 웹 서비스와 같은 모든 데이터 소스의 형태를 취할 수 있습니다.

**인터페이스**

애플리케이션에 연결하기 위해 PostgreSQL 에는 내장 인터페이스 libqs(C 어플리케이션 인터페이스) 및 ECPG(임베디드 C 시스템)

가 포함되어 있다. PostgreSQL 에 연결하기 위한 라이브러리는 많은 언어 플랫폼에서 갖추고 있다.

**동시성 모델**

PostgreSQL 서버는 프로세스 기반이며, 데이터베이스 세션당 하나의 운영체제 프로세스를 사용한다. 다중 세션은 운영체제에 의해

사용 가능한 모든 CPU에 자동으로 분산된다. 여러 CPU 또는 코어를 활용하여 여러 백그라운드 작업자 프로세스에서 여러 유형의

쿼리를 병렬화할 수 있다. 클라이언트에선 멀티 스레드 방식을 이용하여 각 스레드에서 여러 데이터베이스 연결을 만들 수 있다.

### 2.8.4 서비스내 기능

DBMS 로서 DB 를 유저에게 필요한 데이터를 저장하고 관리하는 역할을 수행한다.

## 2.9 코모란(Komoran)

#### 2.9.1 코모란 소개

Komoran 은 Shineware 사에서 개발한 한국어 형태소 분석기로서 java 라이브러리 형태로 제공된다. 타 형태소 분석기와

다르게 여러 어절을 하나의 품사로 분석 가능함으로써 형태소 분석기의 적용 분야에 따라 공백이 포함된 고유명사를 더

정확하게 분석할 수 있습니다.

### 2.9.2 코모란 라이선스

Komoran 은 Apache 2.0 라이선스를 사용하여 누구나 해당 소프트웨어를 개인적, 상용적 목적으로 자유롭게 이용할

수 있다. 사용 시에는 Apache 라이선스의 버전 및 표기를 명시해야 한다.

### 2.9.3 코모란 특징

- Pure Java : 완전히 Java로만 개발되었기 때문에 자바가 설치된 환경이라면 어디서든지 사용 가능합니다.
- 외부 라이브러리 독립적 : 자체 제작한 라이브러리들만을 사용하여 외부 라이브러리와의 의존성 문제가 없습니다.
- 경량화 : 자소 단위 처리, TRIE 사전 등으로 약 50MB 의 적은 메모리상에서도 동작 가능합니다.
- Easy to Use : 라이브러리 적용 후 소스 코드내 1줄만 추가하여 형태소 분석기를 사용할 수 있습니다.
- 사전 관리 용이 : 일반 텍스트 파일의 형태로 구성되어 가독성이 높으며 바로 편집이 가능합니다.
- 새로운 분석 결과 : 타 형태소 분석기와 달리 공백이 포함된 형태소 단위로 분석이 가능합니다.

### 2.9.4 서비스내 기능

맥주 리뷰 데이터를 토큰화후 정제, 분석하여 DB 에 저장하는 역할을 수행합니다.

## 3. DFD

[![dfd](https://user-images.githubusercontent.com/101340860/205447747-0617eed7-0b8d-4e8f-a8ae-6a20fbfd2c56.jpg)](https://user-images.githubusercontent.com/101340860/205447747-0617eed7-0b8d-4e8f-a8ae-6a20fbfd2c56.jpg)

**data flow sequence**

1. 사용자는 라벨 사진이나, 바코드 사진을 통해 원하는 맥주 정보를 검색합니다.

2. 라벨 사진으로 검색하는 경우 구글 비젼 API 를 통해 라벨 사진에 적혀 있는 텍스트를 추출합니다.

3. DB에는 Scrapy 를 통해 크롤링한 맥주 정보와 그와 연관된 정리된 추천 데이터들이 미리 준비되어 있습니다.

4. 추출된 텍스트 데이터와 일치하는 정보가 DB 내에 존재할 경우 사용자에게 그 결과를 바로 웹을 통해 전달합니다.

5. DB 내에 일치 데이터가 존재하지 않을 경우 해당 데이터를 Elastic search 에 넘겨 검색된 정보를 웹을 통해 사용자에게 전달합니다.

6. 바코드 사진으로 검색하는 경우 사용자가 촬영한 바코드 사진이 ZXING 에 넘겨지고 사진에서 바코드 정보를 추출합니다.

7. 바코드 정보를 앞선 경우와 마찬가지로 DB 내에 있는 데이터와 대조하거나 Elastic serach 에 넘겨 검색 정보를 받아오는 식으로

   사용자에게 정보를 제공합니다.

8. 서비스에서는 각각의 맥주에 대한 사용자들의 리뷰 데이터를 Komoran 을 통해 토큰화된 형태로 정제하여 DB에 저장하고

   사용자가 검색시에 살펴볼 수 있도록 제시합니다.

9. 앱과 웹을 개발하는 데는 오픈 소스 라이선스를 사용하는 IDE 인 안드로이드 스튜디오, 부트스트랩/스프링 웹프레임워크가

   사용되었습니다.

### 4. 라이선스 검토

------

| 오픈소스                | 라이선스                                          | 충돌 여부 |
| ----------------------- | ------------------------------------------------- | --------- |
| Bootstrap               | MIT License (3.1.0 이전까지는 Apache License 2.0) | X         |
| Spring                  | Apache License 2.0                                | X         |
| Android Studio          | Apache License 2.0                                | X         |
| Google Cloud Vision API | API                                               | X         |
| Zxing                   | Apache License 2.0                                | X         |
| Elastic Search          | Apache License 2.0 -> SSPL 1.0 & Elastic License  | X         |
| Komoran                 | Apache License 2.0                                | X         |

<details class="details-reset details-overlay details-overlay-dark" id="jumpto-line-details-dialog" style="box-sizing: border-box; display: block;"><summary data-hotkey="l" aria-label="Jump to line" role="button" style="box-sizing: border-box; display: list-item; cursor: pointer; list-style: none; transition: color 80ms cubic-bezier(0.33, 1, 0.68, 1) 0s, background-color, box-shadow, border-color;"></summary></details>

## 